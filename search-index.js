var searchIndex = JSON.parse('{\
"storage_api":{"doc":"A proof-of-concept implementation of (one version of) the …","t":[3,3,3,3,3,16,3,6,8,8,3,3,8,3,8,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,10,11,10,11,11,11,11,11,10,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11],"n":["AllocHandle","AllocStorage","BorrowedStorage","Box","DynStorage","Handle","InlineStorage","Memory","MultipleStorage","PinningStorage","RawBox","RawVec","SharedMutabilityStorage","SmallStorage","Storage","allocate","allocate","allocate","allocate","allocate","allocate","as_mut","as_mut","as_mut_ptr","as_ptr","as_ref","as_ref","as_sized_ptr","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","boxed","clone","cmp","deallocate","deallocate","deallocate","deallocate","deallocate","deallocate","deref","deref_mut","drop","drop","drop","eq","fits","fits","fmt","from","from","from","from","from","from","from","from","from","from_raw_parts","from_raw_parts","grow","grow","grow","grow","grow","grow","grow_to","hash","inline","into","into","into","into","into","into","into","into","into","into_raw_parts","into_raw_parts","len","metadata","ne","new","new","new","new","new","new","new_in","partial_cmp","replace_ptr","resolve","resolve","resolve","resolve","resolve","resolve","resolve_many_mut","resolve_many_mut","resolve_mut","resolve_mut","resolve_mut","resolve_mut","resolve_mut","resolve_mut","resolve_raw","resolve_raw","shrink","shrink","shrink","shrink","shrink","shrink","shrink_to","take","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id"],"q":["storage_api","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["","A storage that stores objects via an <code>Allocator</code>.","A single storage which stores memory in borrowed space.","A pointer type for heap allocation. A tiny subset of std’…","Dynamic single storage for use with …","The handle which is used to access the stored memory.","A single storage which stores memory inline.","","A storage that can manage multiple memory handles.","A storage that allocates pinned memory handles.","A raw box around some storage. Bundles the storage and its …","A raw vec around some slice storage. Bundles the storage …","A storage that serves as a uniqueness barrier.","A single storage which stores memory inline if it fits, …","Types which can be used to manage memory handles.","Allocate memory handle in this storage.","","","","","","Get a mutable reference to the boxed object.","Get a mutable reference to the boxed slice.","Get a pointer valid for reads and writes to the boxed …","Get a pointer valid <em>for reads only</em> to the boxed object.","Get a reference to the boxed object.","Get a reference to the boxed slice.","","","","","","","","","","","","","","","","","","","","Construct a dynamic storage box from a standard box.","","","Deallocate an object handle in this storage.","","","Deallocation is a no-op. When the boxed T is dropped, the …","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Reassemble a raw box from its component parts.","","Grow a memory handle to a larger size.","","","","","","Grow the length of the slice to <code>new_len</code>. Does not change …","","Construct a dynamic storage box inline.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Break a raw box into its component parts.","","Get the length of the slice.","Get the metadata of the boxed object.","","","","","Create a new box for the object described by the given …","Create a new empty growable slice in the given storage.","","","","","Resolve a memory handle in this storage to a reference.","","","","","","Resolve memory handles in this storage to mutable …","","Resolve a memory handle in this storage to a mutable …","","","","","","Resolve a memory handle in this storage to a mutable …","","Shrink a memory handle to a smaller size.","","","","","","Shrink the length of the slice to <code>new_len</code>. Does not change …","Construct a dynamic storage box by taking someone else’s …","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,7,7,7,8,9,2,3,4,5,7,9,8,6,10,2,3,4,5,7,9,8,6,10,9,10,10,1,2,3,4,5,6,9,9,7,9,8,10,3,5,10,2,3,4,5,7,9,8,6,10,7,9,1,2,3,4,5,6,8,10,9,2,3,4,5,7,9,8,6,10,7,9,8,7,10,2,3,5,7,8,6,9,10,9,1,2,3,4,5,6,11,2,1,2,3,4,5,6,12,2,1,2,3,4,5,6,8,9,2,3,4,5,7,9,8,6,10,2,3,4,5,7,9,8,6,10,2,3,4,5,7,9,8,6,10],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[["",0],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0]],["maybeuninit",19]],[[["",0]]],[[["",0]]],[[["",0]]],[[["",0]],["maybeuninit",19]],[[["",0]]],[[["",0]]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["box",3,[["allocstorage",3]]]]],[[["",0]],["allochandle",3]],[[["",0],["allochandle",3]],["ordering",4]],[[["",0],["layout",3]]],[[["",0],["layout",3]]],[[["",0],["layout",3]]],[[["",0],["layout",3]]],[[["",0],["layout",3]]],[[["",0],["layout",3]]],[[["",0]]],[[["",0]]],[[["",0]]],[[["",0]]],[[["",0]]],[[["",0],["allochandle",3]],["bool",0]],[[["",0],["layout",3]],["bool",0]],[[["",0],["layout",3]],["bool",0]],[[["",0],["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["",0],["layout",3],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["usize",0]],["result",4,[["allocerror",3]]]],[[["",0],["",0]]],[[["box",3,[["inlinestorage",3,[["usize",0]]]]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["",0]],["usize",0]],[[["",0]]],[[["",0],["allochandle",3]],["bool",0]],[[]],[[["maybeuninit",19]]],[[]],[[],["result",4]],[[],["result",4]],[[]],[[]],[[["",0],["allochandle",3]],["option",4,[["ordering",4]]]],[[]],[[["",0],["layout",3]],["memory",6]],[[["",0],["layout",3]],["memory",6]],[[["",0],["layout",3]],["memory",6]],[[["",0],["layout",3]],["memory",6]],[[["",0],["layout",3]],["memory",6]],[[["",0],["layout",3]],["memory",6]],[[["",0]]],[[["",0]]],[[["",0],["layout",3]],["memory",6]],[[["",0],["layout",3]],["memory",6]],[[["",0],["layout",3]],["memory",6]],[[["",0],["layout",3]],["memory",6]],[[["",0],["layout",3]],["memory",6]],[[["",0],["layout",3]],["memory",6]],[[["",0],["layout",3]],["memory",6]],[[["",0],["layout",3]],["memory",6]],[[["",0],["layout",3],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["layout",3],["layout",3]],["result",4,[["allocerror",3]]]],[[["",0],["usize",0]],["result",4,[["allocerror",3]]]],[[["manuallydrop",3]]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]]],"p":[[8,"Storage"],[3,"AllocStorage"],[3,"BorrowedStorage"],[3,"DynStorage"],[3,"InlineStorage"],[3,"SmallStorage"],[3,"RawBox"],[3,"RawVec"],[3,"Box"],[3,"AllocHandle"],[8,"MultipleStorage"],[8,"SharedMutabilityStorage"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};