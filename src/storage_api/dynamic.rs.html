<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/dynamic.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>dynamic.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../storage_api/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../storage_api/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../storage_api/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
</pre><pre class="rust"><code><span class="kw">use</span> {
    <span class="kw">crate</span>::{
        <span class="ident">polyfill</span>::{<span class="ident">is_zst</span>, <span class="ident">Bool</span>, <span class="ident">True</span>},
        <span class="ident">AllocStorage</span>, <span class="ident">Box</span>, <span class="ident">InlineStorage</span>, <span class="ident">Storage</span>,
    },
    <span class="ident">core</span>::{
        <span class="ident">alloc::Allocator</span>,
        <span class="ident">marker::PhantomData</span>,
        <span class="ident">mem</span>::{<span class="ident">ManuallyDrop</span>, <span class="ident">MaybeUninit</span>},
        <span class="ident">ptr</span>::{<span class="self">self</span>, <span class="ident">Pointee</span>},
    },
};

<span class="comment">/*

--------------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Read This! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--------------------------------------------------------------------------------


Okay, so sit down and brace yourself. This is quite complicated and subtle, and
basically *all* of it has to be understood in order to comprehend *any* of what
is going on here.

The goal is to be able to use RawBox&lt;dyn Trait, DynStorage&gt; as a polymorphic
storage that can be used to handle any of the following types uniformly:

- RawBox&lt;T, AllocStorage&lt;A&gt;&gt;
- RawBox&lt;T, InlineStorage&lt;usize&gt;&gt;
- RawBox&lt;T, SmallStorage&lt;usize&gt;&gt;
- &amp;move T (equivalently &amp;mut ManuallyDrop&lt;T&gt; where we claim the drop)
- T where Layout::new::&lt;T&gt;().fits_in(Layout::new::&lt;usize&gt;())
- *maybe* &amp;mut T? figuring that out as I go...
- *maybe* other DerefMut smart pointers? figuring that out as I go...

and for this to all be the size of 2Ã—usize -- that of Box&lt;dyn T, Global&gt;.

Naively, this would take 4Ã—usize, and roughly look like

struct RawBox&lt;dyn Trait, DynStorage&lt;A&gt;&gt; {
    handle: NonNull&lt;()&gt;,
    metadata: &amp;&#39;static VTable&lt;dyn &lt;T as Trait&gt;&gt;,
    storage: struct RawBox {
        handle: (),
        metadata: &amp;&#39;static VTable&lt;dyn Storage&gt;,
        storage: SmallStorage&lt;usize&gt;,
    }
}

We can get this down to 3Ã—usize fairly simply by using the SmallStorage trick:
switching between InlineStorage and AllocStorage (and just those two) based not
on a vtable, but on the size of the stored memory.

struct RawBox&lt;dyn Trait, DynStorage&lt;A&gt;&gt; {
    handle: (),
    metadata: &amp;&#39;static VTable&lt;dyn &lt;T as Trait&gt;&gt;,
    storage: SmallStorage&lt;usize, A&gt;,
}

but -- why don&#39;t we just use SmallStorage then? The reason, and problem, is that
we also want to support &amp;move T, stealing the memory from somewhere else. This
allows handling types larger than usize without allocating memory.

Readers paying close attention will notice that the above raw box layout is
actually only 2Ã—usize. That&#39;s why the simple DynStorage&lt;A&gt; results in a 3Ã—usize
box: we use a handle of Option&lt;NonNull&lt;()&gt;&gt;, an a non-null pointer means that
we have a borrowed item, not a stored item.

struct RawBox&lt;dyn Trait, DynStorage&lt;&#39;a, A&gt;&gt; {
    handle: Option&lt;NonNull&lt;()&gt;&gt;,
    metadata: &amp;&#39;static VTable&lt;dyn &lt;T as Trait&gt;&gt;,
    storage: DynStorage(SmallStorage&lt;usize, A&gt;),
}

If you want to support &amp;mut T, note that &amp;mut T behaves equivalently *here* to
&amp;move ButDontDrop&lt;T&gt; (i.e. &amp;move ManuallyDrop&lt;T&gt;). So long as T: Trait implies
ButDontDrop&lt;T&gt;: Trait, supporting &amp;mut T is no extra work.[^1]

This is fairly trivial to implement, just requiring a bit of plumbing but no
real difficult implementation tricks. Note that we don&#39;t use Storage::allocate;
instead, we convert straight to RawBox&lt;dyn Trait, DynStorage&lt;A&gt;&gt;.

type Handle = DynHandle(Option&lt;NonNull&lt;()&gt;&gt;);
fn allocate, grow, shrink = unreachable!()
fn resolve[_mut] = if let Some(ptr) = handle {
    ptr::from_raw_parts[_mut](ptr, metadata)
} else {
    storage.resolve[_mut](())
}

Note that this implementation doesn&#39;t use the fact that we&#39;re restricting
ourselves to dyn Trait at all; it works for any type at all, with or without
unsizing. The utility of this specific solution doing extra state to support
inline storage probably isn&#39;t useful for e.g. slices, though.

The remaining redundancy in our 3Ã—usize solution is that we either use the
handle *or* the storage, leaving a dead usize in our layout either way. How do
we remove this wasted space, and get a 2Ã—usize layout? SmallStorage is valid for
any usize bit pattern, and NonNull&lt;()&gt; only has one invalid bit pattern, which
we&#39;re using to choose if we&#39;re borrowed memory or owned memory.

The solution is in the vtable. &amp;move T and Box&lt;T&gt; only differ in one thing:
what dropping does. drop(&amp;move T) does drop_in_place(*mut T). drop(Box&lt;T&gt;) does
drop_in_place(*mut T) plus dealloc(*mut T). Otherwise, the pointer is handled
exactly the same[^3].

This also means our DynStorage is no longer allocator specific, but it trades
this for another restriction: it must be only used with ZST allocators, as there
is no way to pass in an allocator parameter to the vtable dynamic drop_in_place.
The hope is that things like arena allocators would be able to make do with just
&amp;move semantics and freeing the memory afterwards. This may need revisiting.

struct RawBox&lt;dyn Trait, DynStorage&lt;&#39;a&gt;&gt; {
    handle: (),
    metadata: &amp;&#39;static VTable&lt;dyn Trait&#39;&gt;,
    storage: DynStorage&lt;&#39;a&gt;,
}

A simple implementation eagerly moves small types out of indirections and into
the inline storage. This means that it cannot be used for &amp;mut T[^1], as it
would mutate the T in place for small Ts. The solution to this is to have &amp;mut T
keep the indirection, but how do you tell apart small inline T and &amp;mut T?

The answer is, again, to put the information into the vtable. It is [always safe
for an integer to pretend to be a pointer](ptr::invalid), so &quot;all&quot; that needs to
be done is to provide a vtable which turns the given pointer address back into
the small pointer-address-sized T and dispatches to Ts implementation. Simple
enough in theory, but complicated in practice, especially without compiler
support[^3].

It&#39;s much the same thing for other custom DerefMut smart pointers. So long as
the smart pointer can into_raw into *mut T and from_raw from *mut T, generating
a wrapping vtable is as simple as (whatever magic to generate such vtable and)
making drop_in_place from_raw the smart pointer to drop it.

Pointers which are *not* DerefMut are also theoretically suportable, so long as
we somehow provide two key guarantees:

- The trait only uses T by-reference, not by-mutable-reference, and
- It is considered unsound to downcast RawBox&lt;dyn Trait, DynStorage&lt;&#39;a&gt;&gt; to a
  concrete type. Doing so is already *very* sketchy, though, given all of the
  magic going on to semi-transparently change the type (vtable) of the boxed
  object to handle the hyper-polymorphic drop_in_place.

--------------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Additional notes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--------------------------------------------------------------------------------

[^1]: &amp;move ManuallyDrop&lt;T&gt; cannot be used for &amp;mut T in general. The problem
(which the later scheme hits) is that &amp;mut T requires any modification to
happen in-place, where &amp;move deliberately makes *no* guarantees beyond leaving
the place in a valid-but-unspecified (ideally[^2] dropped) state.

[^2]: Remember: mem::forget is safe. &amp;move T doesn&#39;t actually *have* to drop.

[^3]: In order to to provide wrapped vtables, we need compiler support. Instead,
we do something terrible: we just leak any heap allocation. Additionally, since
we can&#39;t wrap vtables, we move all small data inline, so that we don&#39;t need the
vtable to desmuggle pointer-sized values. We don&#39;t support &amp;mut T; if T is large
enough to not fit inline, you can use &amp;mut ManuallyDrop&lt;ManuallyDrop&lt;T&gt;&gt;, but we
acknowledge that this is a bad solution. What compiler support for this would
look like, though, I have no clue at the moment.

--------------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~ Time for the Actual Impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~
--------------------------------------------------------------------------------

... now that I&#39;ve written 150 lines of justification ðŸ˜…

This file is written in a semi literate code style, to best ensure that the code
and the justification match, and that everything works as expected. This code is
subtle -- even subtly subtle at that -- so deserves every chance it can get at
being more transparent to future readers.

*/</span>

<span class="kw">use</span> <span class="ident">core</span>::{
    <span class="ident">alloc</span>::{<span class="ident">AllocError</span>, <span class="ident">Layout</span>},
    <span class="ident">mem</span>,
    <span class="ident">ptr::DynMetadata</span>,
};

<span class="kw">use</span> <span class="kw">crate</span>::{<span class="ident">polyfill::layout_fits_in</span>, <span class="ident">Memory</span>, <span class="ident">SharedMutabilityStorage</span>};

<span class="doccomment">/// Dynamic single storage for use with `RawBox&lt;dyn Trait, DynStorage&lt;A&gt;&gt;`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// `DynStorage` cannot be constructed directly. Instead, you can convert any</span>
<span class="doccomment">/// of the following pointer types into `RawBox&lt;dyn Trait, DynStorage&gt;`, given</span>
<span class="doccomment">/// you have `T: Trait`:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `RawBox&lt;T, AllocStorage&lt;A&gt;&gt;` where `size_of::&lt;A&gt;() == 0`</span>
<span class="doccomment">/// - `RawBox&lt;T, InlineStorage&lt;usize&gt;&gt;`</span>
<span class="doccomment">/// - `RawBox&lt;T, SmallStorage&lt;usize, A&gt;&gt;` where `size_of::&lt;A&gt;() == 0`</span>
<span class="doccomment">/// - `&amp;mut ManuallyDrop&lt;T&gt;` (used as &quot;`&amp;move T`&quot;)</span>
<span class="doccomment">/// - `T` where `Layout::new::&lt;T&gt;().fits_in(Layout::new::&lt;usize&gt;())`</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DynStorage</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="comment">// In the storage, we store MaybeUninit&lt;usize&gt; as our actual data store. The</span>
    <span class="comment">// vtable of the boxed object is stored by the RawBox. This data store</span>
    <span class="comment">// stores one of two things:</span>
    <span class="comment">// - if Layout::new::&lt;T&gt;().fits_in(Layout::new::&lt;usize&gt;()), T</span>
    <span class="comment">// - else *mut T</span>
    <span class="ident">storage</span>: <span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>,
    <span class="comment">// If we store a pointer, that pointer must not live its potentially</span>
    <span class="comment">// borrowed backing memory, so we note that we store a reference here.</span>
    <span class="ident">_marker</span>: <span class="ident">PhantomData</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> ()<span class="op">&gt;</span>,
}

<span class="kw">unsafe</span> <span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Storage</span> <span class="kw">for</span> <span class="ident">DynStorage</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="comment">// Our handle type is (); no extra data is stored in the raw box beyond the</span>
    <span class="comment">// storage itself and the pointer metadata. This ensures that our raw box</span>
    <span class="comment">// parts triple of (S::Handle, &lt;dyn Trait as Pointee&gt;::Metadata, S) is only</span>
    <span class="comment">// 2Ã—usize big.</span>
    <span class="kw">type</span> <span class="ident">Handle</span> <span class="op">=</span> ();

    <span class="comment">// Allocation cannot happen. There is no way to construct DynStorage</span>
    <span class="comment">// directly; it is only constructed as part of an already-allocated RawBox.</span>
    <span class="comment">// However, it can be acquired by RawBox::into_raw_parts, so we always fail</span>
    <span class="comment">// allocation, rather than panic or otherwise treat this as unreachable.</span>
    <span class="kw">fn</span> <span class="ident">allocate</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="kw">_</span>: <span class="ident">Layout</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Handle</span>, <span class="ident">AllocError</span><span class="op">&gt;</span> {
        <span class="prelude-val">Err</span>(<span class="ident">AllocError</span>)
    }

    <span class="doccomment">/// Deallocation is a no-op. When the boxed T is dropped, the drop_in_place</span>
    <span class="doccomment">/// call handles any required deallocation.</span>
    <span class="doccomment">/// XXX: This might break the actual Box&#39;s normal API, as it isn&#39;t properly</span>
    <span class="doccomment">///      &quot;DerefPlace&quot; anymore -- normally you can move out of a box and</span>
    <span class="doccomment">///      dealloc it separately, or drop the contents of a box and then</span>
    <span class="doccomment">///      reinitialize it with new contents. If comandeering drop_in_place&lt;T&gt;</span>
    <span class="doccomment">///      like this isn&#39;t viable, we&#39;ll have to instead add a separate entry</span>
    <span class="doccomment">///      for dealloc into the vtable at the end, so it can still be used as</span>
    <span class="doccomment">///      the normal dyn Trait vtable. This might even be preferable if this</span>
    <span class="doccomment">///      is done through more compiler magic than libs code.</span>
    <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">deallocate</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="kw">_</span>: <span class="ident"><span class="self">Self</span>::Handle</span>, <span class="kw">_</span>: <span class="ident">Layout</span>) {}

    <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">resolve</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="kw">_</span>: <span class="ident"><span class="self">Self</span>::Handle</span>, <span class="ident">layout</span>: <span class="ident">Layout</span>) -&gt; <span class="kw-2">&amp;</span><span class="ident">Memory</span> {
        <span class="kw">if</span> <span class="ident">layout_fits_in</span>(<span class="ident">layout</span>, <span class="ident">Layout::for_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">storage</span>)) {
            <span class="comment">// If the layout of the boxed object fits inline, it&#39;s inline. In a</span>
            <span class="comment">// full, vtable-wrapping implementation, we would return the object</span>
            <span class="comment">// typecast as a pointer, but the prototype inlines all small data.</span>
            <span class="comment">// XXX: resolve returns a reference currently. This is nice because</span>
            <span class="comment">//      the lifetime is obvious, rather than having to specify when</span>
            <span class="comment">//      a raw pointer is invalidated, but makes returning an invalid</span>
            <span class="comment">//      pointer definitely illegal...</span>
            <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">ptr::from_raw_parts</span>(<span class="self">self</span>.<span class="ident">storage</span>.<span class="ident">as_ptr</span>().<span class="ident">cast</span>(), <span class="ident">layout</span>.<span class="ident">size</span>())
        } <span class="kw">else</span> {
            <span class="comment">// If it doesn&#39;t, then the inline data is a pointer to the object.</span>
            <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">ptr::from_raw_parts</span>(
                <span class="self">self</span>.<span class="ident">storage</span>.<span class="ident">as_ptr</span>().<span class="ident">cast</span>::<span class="op">&lt;</span><span class="kw-2">*const</span> ()<span class="op">&gt;</span>().<span class="ident">read</span>(),
                <span class="ident">layout</span>.<span class="ident">size</span>(),
            )
        }
    }

    <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">resolve_mut</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="kw">_</span>: <span class="ident"><span class="self">Self</span>::Handle</span>, <span class="ident">layout</span>: <span class="ident">Layout</span>) -&gt; <span class="kw-2">&amp;mut</span> <span class="ident">Memory</span> {
        <span class="kw">if</span> <span class="ident">layout_fits_in</span>(<span class="ident">layout</span>, <span class="ident">Layout::for_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">storage</span>)) {
            <span class="comment">// If the layout of the boxed object fits inline, it&#39;s inline. In a</span>
            <span class="comment">// full, vtable-wrapping implementation, we would return the object</span>
            <span class="comment">// typecast as a pointer, but the prototype inlines all small data.</span>
            <span class="comment">// XXX: resolve_mut returns a reference currently. This is nice</span>
            <span class="comment">//      because the lifetime is obvious, rather than having to</span>
            <span class="comment">//      specify when a raw pointer is invalidated, but makes</span>
            <span class="comment">//      returning an invalid pointer definitely illegal...</span>
            <span class="kw-2">&amp;mut</span> <span class="kw-2">*</span><span class="ident">ptr::from_raw_parts_mut</span>(<span class="self">self</span>.<span class="ident">storage</span>.<span class="ident">as_mut_ptr</span>().<span class="ident">cast</span>(), <span class="ident">layout</span>.<span class="ident">size</span>())
        } <span class="kw">else</span> {
            <span class="comment">// If it doesn&#39;t, then the inline data is a pointer to the object.</span>
            <span class="kw-2">&amp;mut</span> <span class="kw-2">*</span><span class="ident">ptr::from_raw_parts_mut</span>(
                <span class="self">self</span>.<span class="ident">storage</span>.<span class="ident">as_mut_ptr</span>().<span class="ident">cast</span>::<span class="op">&lt;</span><span class="kw-2">*mut</span> ()<span class="op">&gt;</span>().<span class="ident">read</span>(),
                <span class="ident">layout</span>.<span class="ident">size</span>(),
            )
        }
    }

    <span class="comment">// Just like allocation, DynStorage does not support reallocation, as this</span>
    <span class="comment">// is not used by the RawBox API. Again as with allocate, though, these</span>
    <span class="comment">// methods could be called by splitting the box into its raw parts, so just</span>
    <span class="comment">// always fail; it is always safe behavior for reallocation to fail.</span>
    <span class="comment">// XXX: Consider making grow/shrink default implemented to always fail?</span>
    <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">grow</span>(
        <span class="kw-2">&amp;mut</span> <span class="self">self</span>,
        <span class="kw">_</span>: <span class="ident"><span class="self">Self</span>::Handle</span>,
        <span class="kw">_</span>: <span class="ident">Layout</span>,
        <span class="kw">_</span>: <span class="ident">Layout</span>,
    ) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Handle</span>, <span class="ident">AllocError</span><span class="op">&gt;</span> {
        <span class="prelude-val">Err</span>(<span class="ident">AllocError</span>)
    }

    <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">shrink</span>(
        <span class="kw-2">&amp;mut</span> <span class="self">self</span>,
        <span class="kw">_</span>: <span class="ident"><span class="self">Self</span>::Handle</span>,
        <span class="kw">_</span>: <span class="ident">Layout</span>,
        <span class="kw">_</span>: <span class="ident">Layout</span>,
    ) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Handle</span>, <span class="ident">AllocError</span><span class="op">&gt;</span> {
        <span class="prelude-val">Err</span>(<span class="ident">AllocError</span>)
    }
}

<span class="comment">// Now we come to the actual construction of dynamic storage boxes.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">U</span>, <span class="ident">DynStorage</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="comment">// The unsized target type must be dyn Trait.</span>
    <span class="ident">U</span>: <span class="question-mark">?</span><span class="ident">Sized</span> <span class="op">+</span> <span class="ident">Pointee</span><span class="op">&lt;</span><span class="ident">Metadata</span> <span class="op">=</span> <span class="ident">DynMetadata</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span><span class="op">&gt;</span>,
{
    <span class="doccomment">/// Construct a dynamic storage box from a standard box.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">boxed</span><span class="op">&lt;</span><span class="ident">A</span><span class="op">&gt;</span>(
        <span class="comment">// We start with a heap-allocated object.</span>
        <span class="ident">boxed</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">U</span>, <span class="ident">AllocStorage</span><span class="op">&lt;</span><span class="ident">A</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    ) -&gt; <span class="self">Self</span>
    <span class="kw">where</span>
        <span class="comment">// The allocator must be trivial.</span>
        <span class="ident">A</span>: <span class="ident">Copy</span> <span class="op">+</span> <span class="ident">Allocator</span>,
        <span class="ident">Bool</span><span class="op">&lt;</span>{ <span class="ident">is_zst</span>::<span class="op">&lt;</span><span class="ident">A</span><span class="op">&gt;</span>() }<span class="op">&gt;</span>: <span class="ident">True</span>,
    {
        <span class="comment">// Do some paranoia checks that the alloc_storage is indeed trivial.</span>
        <span class="macro">assert_eq!</span>(<span class="ident">mem::size_of</span>::<span class="op">&lt;</span><span class="ident">AllocStorage</span><span class="op">&lt;</span><span class="ident">A</span><span class="op">&gt;</span><span class="op">&gt;</span>(), <span class="number">0</span>);
        <span class="macro">assert!</span>(<span class="op">!</span><span class="ident">mem::needs_drop</span>::<span class="op">&lt;</span><span class="ident">AllocStorage</span><span class="op">&lt;</span><span class="ident">A</span><span class="op">&gt;</span><span class="op">&gt;</span>());

        <span class="comment">// Get the layout of U before deconstructing the box.</span>
        <span class="kw">let</span> <span class="ident">layout</span> <span class="op">=</span> <span class="ident">Layout::for_value</span>::<span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">boxed</span>);

        <span class="comment">// Split the box into its alloc storage, vtable, and alloc handle.</span>
        <span class="kw">let</span> (<span class="ident">alloc_handle</span>, <span class="ident">vtable</span>, <span class="ident">alloc_storage</span>) <span class="op">=</span> <span class="ident">Box::into_raw_parts</span>(<span class="ident">boxed</span>);

        <span class="comment">// Because we control AllocStorage, we know the handle is just a pointer</span>
        <span class="comment">// and that deallocating the handle is just calling Allocator::dealloc.</span>
        <span class="comment">// Convert the handle into just the pointer; forget the trivial storage.</span>
        <span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">alloc_storage</span>.<span class="ident">resolve_raw</span>(<span class="ident">alloc_handle</span>, <span class="ident">layout</span>) }.<span class="ident">as_mut_ptr</span>();
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::forget_non_drop</span>)]</span>
        <span class="ident">mem::forget</span>(<span class="ident">alloc_storage</span>);

        <span class="comment">// This is where the vtable wrapping should happen, but this is not</span>
        <span class="comment">// currently possible without new compiler features, so we just let the</span>
        <span class="comment">// box leak instead, by using the vtable as-is.</span>

        <span class="kw">if</span> <span class="ident">layout_fits_in</span>(<span class="ident">layout</span>, <span class="ident">Layout::new</span>::<span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>()) {
            <span class="comment">// Because we don&#39;t do any vtable wrapping for this prototype, small</span>
            <span class="comment">// values have to be moved inline. Construct an inline box and call</span>
            <span class="comment">// the inline box conversion instead.</span>
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">inline_storage</span> <span class="op">=</span> <span class="ident">InlineStorage</span>::<span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span><span class="ident">::new</span>();
            <span class="ident">inline_storage</span>.<span class="ident">allocate</span>(<span class="ident">layout</span>).<span class="ident">unwrap</span>(); <span class="comment">// already checked layout fits</span>
            <span class="kw">unsafe</span> {
                <span class="kw">let</span> <span class="ident">inline_memory</span> <span class="op">=</span> <span class="ident">inline_storage</span>.<span class="ident">resolve_mut</span>((), <span class="ident">layout</span>);
                <span class="ident">ptr::copy_nonoverlapping</span>(<span class="ident">ptr</span>, <span class="ident">inline_memory</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">layout</span>.<span class="ident">size</span>());
                <span class="kw">return</span> <span class="ident"><span class="self">Self</span>::inline</span>(<span class="ident">Box::from_raw_parts</span>((), <span class="ident">vtable</span>, <span class="ident">inline_storage</span>));
            }
        }

        <span class="comment">// Construct the DynStorage holding the heap pointer.</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dyn_storage</span> <span class="op">=</span> <span class="ident">DynStorage</span> {
            <span class="ident">storage</span>: <span class="ident">MaybeUninit::uninit</span>(),
            <span class="ident">_marker</span>: <span class="ident">PhantomData</span>,
        };
        <span class="kw">unsafe</span> {
            <span class="ident">dyn_storage</span>
                .<span class="ident">storage</span>
                .<span class="ident">as_mut_ptr</span>()
                .<span class="ident">cast</span>::<span class="op">&lt;</span><span class="kw-2">*mut</span> ()<span class="op">&gt;</span>()
                .<span class="ident">write</span>(<span class="ident">ptr</span>.<span class="ident">cast</span>());
        }

        <span class="comment">// Construct the sucessfully storage-erased box.</span>
        <span class="kw">unsafe</span> { <span class="ident">Box::from_raw_parts</span>((), <span class="ident">vtable</span>, <span class="ident">dyn_storage</span>) }
    }

    <span class="doccomment">/// Construct a dynamic storage box inline.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">inline</span>(
        <span class="comment">// We start with an inline-allocated object. Requiring boxing the value</span>
        <span class="comment">// externally simplifies things, but we *could* package it internally.</span>
        <span class="ident">boxed</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">U</span>, <span class="ident">InlineStorage</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    ) -&gt; <span class="self">Self</span> {
        <span class="comment">// Split the box into its vtable and inline storage.</span>
        <span class="kw">let</span> ((), <span class="ident">vtable</span>, <span class="ident">inline_storage</span>) <span class="op">=</span> <span class="ident">Box::into_raw_parts</span>(<span class="ident">boxed</span>);

        <span class="comment">// Because we control InlineStorage, we know it&#39;s just a transparent</span>
        <span class="comment">// wrapper around MaybeUninit&lt;usize&gt;. Rather than trying to handle U,</span>
        <span class="comment">// which is already unsized for us, we just move MaybeUninit&lt;usize&gt;</span>
        <span class="comment">// around, which we know contains the actual U.</span>
        <span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">mem::transmute</span>::<span class="op">&lt;</span><span class="kw">_</span>, <span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">inline_storage</span>) };

        <span class="comment">// This is where the vtable wrapping should happen, but this is not</span>
        <span class="comment">// currently possible without new compiler features, so instead we&#39;ve</span>
        <span class="comment">// ensured that small objects are always known to be inline.</span>

        <span class="comment">// Construct the DynStorage holding the heap pointer.</span>
        <span class="kw">let</span> <span class="ident">dyn_storage</span> <span class="op">=</span> <span class="ident">DynStorage</span> {
            <span class="ident">storage</span>: <span class="ident">memory</span>,
            <span class="ident">_marker</span>: <span class="ident">PhantomData</span>,
        };

        <span class="comment">// Construct the sucessfully storage-erased box.</span>
        <span class="kw">unsafe</span> { <span class="ident">Box::from_raw_parts</span>((), <span class="ident">vtable</span>, <span class="ident">dyn_storage</span>) }
    }

    <span class="doccomment">/// Construct a dynamic storage box by taking someone else&#39;s allocation.</span>
    <span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">take</span>(
        <span class="comment">// We start with a reference to ManuallyDrop which we claim to drop.</span>
        <span class="ident">taken</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">ManuallyDrop</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>,
    ) -&gt; <span class="self">Self</span> {
        <span class="comment">// Get the layout of U before deconstructing the reference.</span>
        <span class="kw">let</span> <span class="ident">layout</span> <span class="op">=</span> <span class="ident">Layout::for_value</span>::<span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">taken</span>);

        <span class="comment">// Split the reference into erased pointer and vtable.</span>
        <span class="kw">let</span> (<span class="ident">ptr</span>, <span class="ident">vtable</span>) <span class="op">=</span> (<span class="ident">taken</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">ManuallyDrop</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">U</span>).<span class="ident">to_raw_parts</span>();

        <span class="kw">if</span> <span class="ident">layout_fits_in</span>(<span class="ident">layout</span>, <span class="ident">Layout::new</span>::<span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>()) {
            <span class="comment">// Because we don&#39;t do any vtable wrapping for this prototype, small</span>
            <span class="comment">// values have to be moved inline. Construct an inline box and call</span>
            <span class="comment">// the inline box conversion instead.</span>
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">inline_storage</span> <span class="op">=</span> <span class="ident">InlineStorage</span>::<span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span><span class="ident">::new</span>();
            <span class="ident">inline_storage</span>.<span class="ident">allocate</span>(<span class="ident">layout</span>).<span class="ident">unwrap</span>(); <span class="comment">// already checked layout fits</span>
            <span class="kw">unsafe</span> {
                <span class="kw">let</span> <span class="ident">inline_memory</span> <span class="op">=</span> <span class="ident">inline_storage</span>.<span class="ident">resolve_mut</span>((), <span class="ident">layout</span>);
                <span class="ident">ptr::copy_nonoverlapping</span>(<span class="ident">ptr</span>.<span class="ident">cast</span>(), <span class="ident">inline_memory</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">layout</span>.<span class="ident">size</span>());
                <span class="kw">return</span> <span class="ident"><span class="self">Self</span>::inline</span>(<span class="ident">Box::from_raw_parts</span>((), <span class="ident">vtable</span>, <span class="ident">inline_storage</span>));
            }
        }

        <span class="comment">// Construct the DynStorage holding the borrowed pointer.</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dyn_storage</span> <span class="op">=</span> <span class="ident">DynStorage</span> {
            <span class="ident">storage</span>: <span class="ident">MaybeUninit::uninit</span>(),
            <span class="ident">_marker</span>: <span class="ident">PhantomData</span>,
        };
        <span class="kw">unsafe</span> {
            <span class="ident">dyn_storage</span>
                .<span class="ident">storage</span>
                .<span class="ident">as_mut_ptr</span>()
                .<span class="ident">cast</span>::<span class="op">&lt;</span><span class="kw-2">*mut</span> ()<span class="op">&gt;</span>()
                .<span class="ident">write</span>(<span class="ident">ptr</span>);
        }

        <span class="comment">// Construct the sucessfully storage-erased box.</span>
        <span class="kw">unsafe</span> { <span class="ident">Box::from_raw_parts</span>((), <span class="ident">vtable</span>, <span class="ident">dyn_storage</span>) }
    }
}
</code></pre></div>
</section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="storage_api" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.62.0-nightly (4dd8b420c 2022-05-01)" ></div>
</body></html>